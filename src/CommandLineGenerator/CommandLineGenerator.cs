// SPDX-FileCopyrightText: Copyright (c) 2026 Logan Bussell
// SPDX-License-Identifier: MIT

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StaticCs;

namespace CommandLineGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class CommandLineGenerator : IIncrementalGenerator
{
    private const string CommandAttributeName = "CommandLineGenerator.CommandAttribute";
    private const string MapCommandLineOptionsAttributeName =
        "CommandLineGenerator.MapCommandLineOptionsAttribute";
    private const string ArgumentAttributeName = "CommandLineGenerator.ArgumentAttribute";
    private const string OptionAttributeName = "CommandLineGenerator.OptionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Always generate the base infrastructure (attributes)
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("Attributes.g.cs", SourceText.From(GenerateAttributes(), Encoding.UTF8));
        });

        // Discover options types with [MapCommandLineOptions]
        var optionsTypes = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                MapCommandLineOptionsAttributeName,
                predicate: static (node, _) =>
                    node is RecordDeclarationSyntax or ClassDeclarationSyntax,
                transform: static (ctx, ct) => GetOptionsTypeInfo(ctx, ct)
            )
            .Where(static o => o is not null)
            .Collect()!;

        // Discover command methods with [Command]
        var commandMethods = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                CommandAttributeName,
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, ct) => GetCommandMethodInfo(ctx, ct)
            )
            .Where(static c => c is not null)
            .Collect()!;

        // Combine options types with command methods
        var combined = commandMethods.Combine(optionsTypes);

        context.RegisterSourceOutput(
            combined,
            static (spc, data) =>
            {
                var commands = data.Left;
                var options = data.Right;
                var optionsDict = options
                    .Where(o => o is not null)
                    .ToDictionary(o => o!.FullTypeName, o => o!);

                GenerateConsoleApp(spc, commands!, optionsDict);
            }
        );

        // Generate mapper classes for each options type
        context.RegisterSourceOutput(
            optionsTypes,
            static (spc, optionsTypes) =>
            {
                foreach (var opt in optionsTypes)
                {
                    if (opt is not null)
                    {
                        GenerateOptionsMapper(spc, opt);
                    }
                }

                // Generate CommandExtensions with AddOptions<T>() for all options types
                GenerateCommandExtensions(spc, optionsTypes);
            }
        );
    }

    private static string GenerateAttributes()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace CommandLineGenerator;

            /// <summary>
            /// Marks a method as a CLI command. The method parameters should be options types
            /// decorated with <see cref="MapCommandLineOptionsAttribute"/>.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
            internal sealed class CommandAttribute : global::System.Attribute
            {
                public CommandAttribute(string name) => Name = name;
                public CommandAttribute() => Name = "";

                /// <summary>The command name. Empty string for root command.</summary>
                public string Name { get; }

                /// <summary>Description shown in help text.</summary>
                public string? Description { get; set; }
            }

            /// <summary>
            /// Marks a record or class as a container for command-line options and arguments.
            /// Properties without attributes become options; use <see cref="ArgumentAttribute"/> for arguments.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
            internal sealed class MapCommandLineOptionsAttribute : global::System.Attribute
            {
                /// <summary>
                /// When true (default), property names are converted to kebab-case for option names.
                /// </summary>
                public bool UseKebabCase { get; set; } = true;
            }

            /// <summary>
            /// Marks a parameter or property as a CLI option with explicit configuration.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
            internal sealed class OptionAttribute : global::System.Attribute
            {
                /// <summary>The primary option name (e.g., "--verbose"). If null, derived from property name.</summary>
                public string? Name { get; set; }

                /// <summary>Short alias (e.g., "-v").</summary>
                public string? Alias { get; set; }

                /// <summary>Description shown in help text.</summary>
                public string? Description { get; set; }
            }

            /// <summary>
            /// Marks a parameter or property as a positional CLI argument.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
            internal sealed class ArgumentAttribute : global::System.Attribute
            {
                /// <summary>The argument name shown in help text.</summary>
                public string? Name { get; set; }

                /// <summary>Description shown in help text.</summary>
                public string? Description { get; set; }
            }
            """;
    }

    private static OptionsTypeInfo? GetOptionsTypeInfo(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct
    )
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol)
            return null;

        var mapAttr = ctx.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == MapCommandLineOptionsAttributeName
        );

        if (mapAttr is null)
            return null;

        // Check for UseKebabCase property
        var useKebabCase = true;
        foreach (var namedArg in mapAttr.NamedArguments)
        {
            if (namedArg.Key == "UseKebabCase" && namedArg.Value.Value is bool val)
            {
                useKebabCase = val;
            }
        }

        // Get members from primary constructor parameters (for records) or properties
        var members = new List<OptionsMemberInfo>();

        // Check for primary constructor (records and classes with primary constructors)
        var primaryCtor = typeSymbol.InstanceConstructors.FirstOrDefault(c =>
            c.Parameters.Length > 0
            && c.DeclaringSyntaxReferences.Any(r =>
                r.GetSyntax(ct) is RecordDeclarationSyntax or ClassDeclarationSyntax
            )
        );

        if (primaryCtor is not null)
        {
            foreach (var param in primaryCtor.Parameters)
            {
                var memberInfo = ExtractMemberInfo(param, useKebabCase);
                members.Add(memberInfo);
            }
        }
        else
        {
            // Fall back to public properties with public setters or init
            foreach (var prop in typeSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                if (prop.DeclaredAccessibility != Accessibility.Public)
                    continue;
                if (
                    prop.SetMethod is null
                    || prop.SetMethod.DeclaredAccessibility != Accessibility.Public
                )
                    continue;

                var memberInfo = ExtractMemberInfoFromProperty(prop, useKebabCase);
                members.Add(memberInfo);
            }
        }

        var ns = typeSymbol.ContainingNamespace.ToDisplayString();
        var fullTypeName =
            string.IsNullOrEmpty(ns) || ns == "<global namespace>"
                ? $"global::{typeSymbol.Name}"
                : $"global::{ns}.{typeSymbol.Name}";

        return new OptionsTypeInfo(
            ns,
            typeSymbol.Name,
            fullTypeName,
            members.ToImmutableArray(),
            useKebabCase
        );
    }

    private static OptionsMemberInfo ExtractMemberInfo(IParameterSymbol param, bool useKebabCase)
    {
        var isArgument = false;
        string? explicitName = null;
        string? alias = null;
        string? description = null;

        foreach (var attr in param.GetAttributes())
        {
            var attrName = attr.AttributeClass?.ToDisplayString();

            if (attrName == ArgumentAttributeName)
            {
                isArgument = true;
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "Name")
                        explicitName = namedArg.Value.Value as string;
                    if (namedArg.Key == "Description")
                        description = namedArg.Value.Value as string;
                }
            }
            else if (attrName == OptionAttributeName)
            {
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "Name")
                        explicitName = namedArg.Value.Value as string;
                    if (namedArg.Key == "Alias")
                        alias = namedArg.Value.Value as string;
                    if (namedArg.Key == "Description")
                        description = namedArg.Value.Value as string;
                }
            }
        }

        var cliName = explicitName ?? (useKebabCase ? ToKebabCase(param.Name) : param.Name);
        var isBoolean = param.Type.SpecialType == SpecialType.System_Boolean;

        return new OptionsMemberInfo(
            param.Name,
            param.Type.ToDisplayString(),
            cliName,
            isArgument,
            isBoolean,
            param.NullableAnnotation == NullableAnnotation.Annotated,
            param.HasExplicitDefaultValue,
            param.HasExplicitDefaultValue
                ? FormatDefaultValue(param.ExplicitDefaultValue, param.Type)
                : null,
            alias,
            description
        );
    }

    private static OptionsMemberInfo ExtractMemberInfoFromProperty(
        IPropertySymbol prop,
        bool useKebabCase
    )
    {
        var isArgument = false;
        string? explicitName = null;
        string? alias = null;
        string? description = null;

        foreach (var attr in prop.GetAttributes())
        {
            var attrName = attr.AttributeClass?.ToDisplayString();

            if (attrName == ArgumentAttributeName)
            {
                isArgument = true;
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "Name")
                        explicitName = namedArg.Value.Value as string;
                    if (namedArg.Key == "Description")
                        description = namedArg.Value.Value as string;
                }
            }
            else if (attrName == OptionAttributeName)
            {
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "Name")
                        explicitName = namedArg.Value.Value as string;
                    if (namedArg.Key == "Alias")
                        alias = namedArg.Value.Value as string;
                    if (namedArg.Key == "Description")
                        description = namedArg.Value.Value as string;
                }
            }
        }

        var cliName = explicitName ?? (useKebabCase ? ToKebabCase(prop.Name) : prop.Name);
        var isBoolean = prop.Type.SpecialType == SpecialType.System_Boolean;

        // Properties don't have default values in the same way; we'd need to analyze initializers
        return new OptionsMemberInfo(
            prop.Name,
            prop.Type.ToDisplayString(),
            cliName,
            isArgument,
            isBoolean,
            prop.NullableAnnotation == NullableAnnotation.Annotated,
            false,
            null,
            alias,
            description
        );
    }

    private static CommandMethodInfo? GetCommandMethodInfo(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct
    )
    {
        if (ctx.TargetSymbol is not IMethodSymbol methodSymbol)
            return null;

        var commandAttr = ctx.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == CommandAttributeName
        );

        if (commandAttr is null)
            return null;

        var commandName =
            commandAttr.ConstructorArguments.Length > 0
                ? commandAttr.ConstructorArguments[0].Value as string ?? ""
                : "";

        string? description = null;
        foreach (var namedArg in commandAttr.NamedArguments)
        {
            if (namedArg.Key == "Description")
                description = namedArg.Value.Value as string;
        }

        var containingType = methodSymbol.ContainingType;
        var containingNs = containingType.ContainingNamespace.ToDisplayString();
        var containingFullName =
            string.IsNullOrEmpty(containingNs) || containingNs == "<global namespace>"
                ? $"global::{containingType.Name}"
                : $"global::{containingNs}.{containingType.Name}";

        // Extract parameter types (should be options types)
        var optionsTypeNames = methodSymbol
            .Parameters.Select(p =>
            {
                var ns = p.Type.ContainingNamespace?.ToDisplayString() ?? "";
                return string.IsNullOrEmpty(ns) || ns == "<global namespace>"
                    ? $"global::{p.Type.Name}"
                    : $"global::{ns}.{p.Type.Name}";
            })
            .ToImmutableArray();

        // Check if method returns Task (async) or void (sync)
        var returnType = methodSymbol.ReturnType;
        var isAsync =
            returnType.Name == "Task"
            && returnType.ContainingNamespace?.ToDisplayString() == "System.Threading.Tasks";

        return new CommandMethodInfo(
            containingNs,
            containingType.Name,
            containingFullName,
            methodSymbol.Name,
            commandName,
            description,
            optionsTypeNames,
            isAsync
        );
    }

    private static string ToKebabCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        // Insert hyphen before each uppercase letter (except the first), then lowercase
        var result = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (i > 0 && char.IsUpper(c))
            {
                result.Append('-');
            }
            result.Append(char.ToLowerInvariant(c));
        }
        return result.ToString();
    }

    private static string FormatDefaultValue(object? value, ITypeSymbol type)
    {
        if (value is null)
            return "null";

        if (type.SpecialType == SpecialType.System_String)
            return $"\"{value}\"";

        if (type.SpecialType == SpecialType.System_Boolean)
            return value.ToString()!.ToLowerInvariant();

        return value.ToString()!;
    }

    private static void GenerateConsoleApp(
        SourceProductionContext ctx,
        ImmutableArray<CommandMethodInfo?> commands,
        Dictionary<string, OptionsTypeInfo> optionsTypes
    )
    {
        // Skip generating ConsoleApp if there are no commands
        var validCommands = commands.Where(c => c is not null).ToList();
        if (validCommands.Count == 0)
            return;

        var builder = new IndentingBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.CommandLine;");
        builder.AppendLine("using System.Diagnostics.CodeAnalysis;");
        builder.AppendLine("using System.Threading;");
        builder.AppendLine("using System.Threading.Tasks;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine("using Microsoft.Extensions.Hosting;");
        builder.AppendLine("");
        builder.AppendLine("namespace CommandLineGenerator;");
        builder.AppendLine("");

        // Generate ConsoleApp static class
        builder.AppendLine("internal static class ConsoleApp");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine(
            "public static ConsoleAppBuilder CreateBuilder(string[] args) => new(args);"
        );
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        // Generate ConsoleAppBuilder
        builder.AppendLine("internal sealed class ConsoleAppBuilder");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine("private readonly string[] _args;");
        builder.AppendLine(
            "private readonly List<Func<IServiceProvider, Command>> _commandFactories = [];"
        );
        builder.AppendLine("private Func<IServiceProvider, RootCommand>? _rootCommandFactory;");
        builder.AppendLine("");

        builder.AppendLine("internal ConsoleAppBuilder(string[] args)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("_args = args;");
        builder.AppendLine("var settings = new HostApplicationBuilderSettings { Args = args };");
        builder.AppendLine(
            "Host = Microsoft.Extensions.Hosting.Host.CreateEmptyApplicationBuilder(settings);"
        );
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        builder.AppendLine("public HostApplicationBuilder Host { get; }");
        builder.AppendLine("");

        // Generate a single AddCommand<T>() that switches on type
        builder.AppendLine(
            "public ConsoleAppBuilder AddCommand<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>() where T : class"
        );
        builder.AppendLine("{");
        builder.Indent();

        // Generate switch cases for each command - keyed by containing class
        var containingClasses = validCommands.GroupBy(c => c!.ContainingClassFullName).ToList();

        if (containingClasses.Count > 0)
        {
            for (int i = 0; i < containingClasses.Count; i++)
            {
                var group = containingClasses[i];
                var prefix = i == 0 ? "if" : "else if";
                var firstCmd = group.First()!;

                builder.AppendLine(
                    $"{prefix} (typeof(T) == typeof({firstCmd.ContainingClassFullName}))"
                );
                builder.AppendLine("{");
                builder.Indent();
                builder.AppendLine(
                    $"Host.Services.AddTransient<{firstCmd.ContainingClassFullName}>();"
                );

                foreach (var cmd in group)
                {
                    var factoryName = $"Create{firstCmd.ContainingClassName}_{cmd!.MethodName}";
                    if (cmd.IsRoot)
                    {
                        builder.AppendLine($"_rootCommandFactory = sp => {factoryName}(sp);");
                    }
                    else
                    {
                        builder.AppendLine($"_commandFactories.Add(sp => {factoryName}(sp));");
                    }
                }

                builder.Dedent();
                builder.AppendLine("}");
            }

            builder.AppendLine("else");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine(
                "throw new InvalidOperationException($\"Type '{typeof(T).FullName}' is not a registered command class.\");"
            );
            builder.Dedent();
            builder.AppendLine("}");
        }
        else
        {
            builder.AppendLine(
                "throw new InvalidOperationException($\"Type '{typeof(T).FullName}' is not a registered command class.\");"
            );
        }

        builder.AppendLine("");
        builder.AppendLine("return this;");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        // Generate private factory methods for each command method
        foreach (var cmd in commands)
        {
            if (cmd is null)
                continue;

            GenerateCommandFactory(builder, cmd, optionsTypes);
            builder.AppendLine("");
        }

        // Generate RunAsync
        builder.AppendLine("public async Task<int> RunAsync()");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("Host.Services.AddSingleton<RootCommand>(sp =>");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("RootCommand root = _rootCommandFactory is not null");
        builder.AppendLine("    ? _rootCommandFactory(sp)");
        builder.AppendLine("    : new RootCommand();");
        builder.AppendLine("");
        builder.AppendLine("foreach (var factory in _commandFactories)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("root.Subcommands.Add(factory(sp));");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");
        builder.AppendLine("return root;");
        builder.Dedent();
        builder.AppendLine("});");
        builder.AppendLine("");
        builder.AppendLine("var host = Host.Build();");
        builder.AppendLine("var rootCommand = host.Services.GetRequiredService<RootCommand>();");
        builder.AppendLine("return await rootCommand.Parse(_args).InvokeAsync();");
        builder.Dedent();
        builder.AppendLine("}");

        builder.Dedent();
        builder.AppendLine("}");

        ctx.AddSource("ConsoleApp.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void GenerateCommandFactory(
        IndentingBuilder builder,
        CommandMethodInfo cmd,
        Dictionary<string, OptionsTypeInfo> optionsTypes
    )
    {
        var returnType = cmd.IsRoot ? "RootCommand" : "Command";
        var factoryName = $"Create{cmd.ContainingClassName}_{cmd.MethodName}";

        builder.AppendLine($"private static {returnType} {factoryName}(IServiceProvider sp)");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine(
            $"var instance = sp.GetRequiredService<{cmd.ContainingClassFullName}>();"
        );
        builder.AppendLine("");

        // Create the command
        if (cmd.IsRoot)
        {
            builder.AppendLine("var command = new RootCommand();");
        }
        else
        {
            builder.AppendLine($"var command = new Command(\"{cmd.CommandName}\");");
        }

        if (cmd.Description is not null)
        {
            builder.AppendLine($"command.Description = \"{EscapeString(cmd.Description)}\";");
        }

        builder.AppendLine("");

        // Add arguments and options from each mapper
        foreach (var optTypeName in cmd.OptionsTypeNames)
        {
            if (optionsTypes.TryGetValue(optTypeName, out var optType))
            {
                var mapperName = GetMapperName(optType);
                builder.AppendLine($"{mapperName}.AddTo(command);");
            }
        }

        builder.AppendLine("");
        builder.AppendLine("command.SetAction(async (parseResult, ct) =>");
        builder.AppendLine("{");
        builder.Indent();

        // Parse options using mappers
        var optionVarNames = new List<string>();
        int optIdx = 0;
        foreach (var optTypeName in cmd.OptionsTypeNames)
        {
            if (optionsTypes.TryGetValue(optTypeName, out var optType))
            {
                var mapperName = GetMapperName(optType);
                var optVarName = $"options{optIdx}";
                optionVarNames.Add(optVarName);

                builder.AppendLine($"var {optVarName} = {mapperName}.Parse(parseResult);");
                optIdx++;
            }
        }

        // Call the method
        var methodArgs = string.Join(", ", optionVarNames);
        if (cmd.IsAsync)
        {
            builder.AppendLine($"await instance.{cmd.MethodName}({methodArgs});");
        }
        else
        {
            builder.AppendLine($"instance.{cmd.MethodName}({methodArgs});");
        }

        builder.Dedent();
        builder.AppendLine("});");
        builder.AppendLine("");
        builder.AppendLine("return command;");

        builder.Dedent();
        builder.AppendLine("}");
    }

    private static string GetMapperName(OptionsTypeInfo optType)
    {
        var hasNamespace =
            !string.IsNullOrEmpty(optType.Namespace) && optType.Namespace != "<global namespace>";
        return hasNamespace
            ? $"global::{optType.Namespace}.{optType.TypeName}Mapper"
            : $"global::{optType.TypeName}Mapper";
    }

    private static string EscapeString(string value)
    {
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static void GenerateOptionsMapper(SourceProductionContext ctx, OptionsTypeInfo info)
    {
        var builder = new IndentingBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.CommandLine;");
        builder.AppendLine("using System.CommandLine.Parsing;");
        builder.AppendLine("");

        var hasNamespace =
            !string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>";
        if (hasNamespace)
        {
            builder.AppendLine($"namespace {info.Namespace};");
            builder.AppendLine("");
        }

        var mapperName = $"{info.TypeName}Mapper";
        builder.AppendLine($"internal static class {mapperName}");
        builder.AppendLine("{");
        builder.Indent();

        // Generate private static symbol properties
        var arguments = info.Members.Where(m => m.IsArgument).ToList();
        var options = info.Members.Where(m => !m.IsArgument).ToList();

        foreach (var member in info.Members)
        {
            var propName = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";

            if (member.IsArgument)
            {
                builder.AppendLine(
                    $"private static Argument<{member.TypeName}> {propName} {{ get; }} = CreateArgument_{member.PropertyName}();"
                );
            }
            else
            {
                builder.AppendLine(
                    $"private static Option<{member.TypeName}> {propName} {{ get; }} = CreateOption_{member.PropertyName}();"
                );
            }
        }

        builder.AppendLine("");

        // Generate AddTo method (internal - accessed by generated CommandExtensions and ConsoleApp)
        builder.AppendLine("internal static void AddTo(Command command)");
        builder.AppendLine("{");
        builder.Indent();
        foreach (var member in info.Members)
        {
            var propName = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";
            builder.AppendLine($"command.Add({propName});");
        }
        builder.Dedent();
        builder.AppendLine("}");

        builder.AppendLine("");

        // Generate Parse method
        builder.AppendLine($"public static {info.FullTypeName} Parse(ParseResult parseResult)");
        builder.AppendLine("{");
        builder.Indent();

        var ctorArgs = new List<string>();
        foreach (var member in info.Members)
        {
            var symbolVar = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";

            if (member.IsNullable)
            {
                ctorArgs.Add($"parseResult.GetValue({symbolVar})");
            }
            else if (member.IsBoolean)
            {
                ctorArgs.Add($"parseResult.GetValue({symbolVar})");
            }
            else if (member.HasDefaultValue)
            {
                ctorArgs.Add($"parseResult.GetValue({symbolVar}) ?? {member.DefaultValue}");
            }
            else
            {
                ctorArgs.Add(
                    $"parseResult.GetValue({symbolVar}) ?? throw new InvalidOperationException(\"{(member.IsArgument ? "Argument" : "Option")} '{member.CliName}' was not provided.\")"
                );
            }
        }

        builder.AppendLine($"return new {info.FullTypeName}(");
        builder.Indent();
        for (int i = 0; i < ctorArgs.Count; i++)
        {
            var suffix = i < ctorArgs.Count - 1 ? "," : ");";
            builder.AppendLine($"{ctorArgs[i]}{suffix}");
        }
        builder.Dedent();

        builder.Dedent();
        builder.AppendLine("}");

        // Generate private factory methods for each symbol
        foreach (var member in info.Members)
        {
            builder.AppendLine("");
            GenerateSymbolFactoryMethod(builder, member);
        }

        builder.Dedent();
        builder.AppendLine("}");

        ctx.AddSource($"{mapperName}.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void GenerateCommandExtensions(
        SourceProductionContext ctx,
        ImmutableArray<OptionsTypeInfo?> optionsTypes
    )
    {
        var validTypes = optionsTypes.Where(o => o is not null).ToList();
        if (validTypes.Count == 0)
            return;

        var builder = new IndentingBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.CommandLine;");
        builder.AppendLine("");
        builder.AppendLine("namespace CommandLineGenerator;");
        builder.AppendLine("");
        builder.AppendLine("internal static class CommandExtensions");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine("/// <summary>");
        builder.AppendLine(
            "/// Adds all arguments and options from the specified options type to the command."
        );
        builder.AppendLine("/// </summary>");
        builder.AppendLine("public static void AddOptions<T>(this Command command)");
        builder.AppendLine("{");
        builder.Indent();

        for (int i = 0; i < validTypes.Count; i++)
        {
            var opt = validTypes[i]!;
            var prefix = i == 0 ? "if" : "else if";
            var mapperName = GetMapperName(opt);

            builder.AppendLine($"{prefix} (typeof(T) == typeof({opt.FullTypeName}))");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine($"{mapperName}.AddTo(command);");
            builder.Dedent();
            builder.AppendLine("}");
        }

        builder.AppendLine("else");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine(
            "throw new InvalidOperationException($\"Type '{typeof(T).FullName}' is not a mapped options type.\");"
        );
        builder.Dedent();
        builder.AppendLine("}");

        builder.Dedent();
        builder.AppendLine("}");

        builder.Dedent();
        builder.AppendLine("}");

        ctx.AddSource("CommandExtensions.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void GenerateSymbolFactoryMethod(
        IndentingBuilder builder,
        OptionsMemberInfo member
    )
    {
        var methodName =
            $"Create{(member.IsArgument ? "Argument" : "Option")}_{member.PropertyName}";

        if (member.IsArgument)
        {
            builder.AppendLine($"private static Argument<{member.TypeName}> {methodName}()");
            builder.AppendLine("{");
            builder.Indent();

            if (member.HasDefaultValue)
            {
                builder.AppendLine(
                    $"var arg = new Argument<{member.TypeName}>(\"{member.CliName}\") {{ DefaultValueFactory = _ => {member.DefaultValue} }};"
                );
            }
            else
            {
                builder.AppendLine(
                    $"var arg = new Argument<{member.TypeName}>(\"{member.CliName}\");"
                );
            }

            if (member.Description is not null)
            {
                builder.AppendLine($"arg.Description = \"{EscapeString(member.Description)}\";");
            }

            builder.AppendLine("return arg;");
            builder.Dedent();
            builder.AppendLine("}");
        }
        else
        {
            builder.AppendLine($"private static Option<{member.TypeName}> {methodName}()");
            builder.AppendLine("{");
            builder.Indent();

            var optName = $"--{member.CliName}";

            if (member.IsBoolean)
            {
                builder.AppendLine(
                    $"var opt = new Option<bool>(\"{optName}\") {{ Arity = ArgumentArity.Zero }};"
                );
                if (member.HasDefaultValue)
                {
                    builder.AppendLine($"opt.DefaultValueFactory = _ => {member.DefaultValue};");
                }
            }
            else if (member.HasDefaultValue)
            {
                builder.AppendLine(
                    $"var opt = new Option<{member.TypeName}>(\"{optName}\") {{ DefaultValueFactory = _ => {member.DefaultValue} }};"
                );
            }
            else
            {
                builder.AppendLine($"var opt = new Option<{member.TypeName}>(\"{optName}\");");
                if (!member.IsNullable)
                {
                    builder.AppendLine("opt.Required = true;");
                }
            }

            if (member.Alias is not null)
            {
                builder.AppendLine($"opt.Aliases.Add(\"{member.Alias}\");");
            }

            if (member.Description is not null)
            {
                builder.AppendLine($"opt.Description = \"{EscapeString(member.Description)}\";");
            }

            builder.AppendLine("return opt;");
            builder.Dedent();
            builder.AppendLine("}");
        }
    }

    // Data models

    private sealed record OptionsTypeInfo(
        string Namespace,
        string TypeName,
        string FullTypeName,
        ImmutableArray<OptionsMemberInfo> Members,
        bool UseKebabCase
    );

    private sealed record OptionsMemberInfo(
        string PropertyName,
        string TypeName,
        string CliName,
        bool IsArgument,
        bool IsBoolean,
        bool IsNullable,
        bool HasDefaultValue,
        string? DefaultValue,
        string? Alias,
        string? Description
    );

    private sealed record CommandMethodInfo(
        string ContainingNamespace,
        string ContainingClassName,
        string ContainingClassFullName,
        string MethodName,
        string CommandName,
        string? Description,
        ImmutableArray<string> OptionsTypeNames,
        bool IsAsync
    )
    {
        public bool IsRoot => string.IsNullOrEmpty(CommandName);
    }
}
