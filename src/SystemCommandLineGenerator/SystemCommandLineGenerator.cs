// SPDX-FileCopyrightText: Copyright (c) 2026 Logan Bussell
// SPDX-License-Identifier: MIT

#nullable enable

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StaticCs;

namespace SystemCommandLineGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class CommandLineGenerator : IIncrementalGenerator
{
    private const string CommandAttributeName = "SystemCommandLineGenerator.CommandAttribute";
    private const string ArgumentAttributeName = "SystemCommandLineGenerator.ArgumentAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Always generate the base infrastructure (attributes, ConsoleApp, ConsoleAppBuilder base)
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("Attributes.g.cs", SourceText.From(GenerateAttributes(), Encoding.UTF8));
        });

        var commandClasses = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                CommandAttributeName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, ct) => GetCommandInfo(ctx, ct)
            )
            .Where(static c => c is not null)!;

        // Collect all commands and generate ConsoleApp + ConsoleAppBuilder
        var allCommands = commandClasses.Collect();

        context.RegisterSourceOutput(
            allCommands,
            static (spc, commands) =>
            {
                GenerateConsoleApp(spc, commands!);
            }
        );
    }

    private static string GenerateAttributes()
    {
        return """
            // <auto-generated/>
            #nullable enable

            namespace SystemCommandLineGenerator;

            [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
            internal sealed class CommandAttribute(string name) : global::System.Attribute
            {
                public string Name { get; } = name;
            }

            [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false, AllowMultiple = false)]
            internal sealed class OptionAttribute : global::System.Attribute { }

            [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false, AllowMultiple = false)]
            internal sealed class ArgumentAttribute : global::System.Attribute { }
            """;
    }

    private static CommandInfo? GetCommandInfo(
        GeneratorAttributeSyntaxContext ctx,
        CancellationToken ct
    )
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol classSymbol)
            return null;

        var commandAttr = ctx.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == CommandAttributeName
        );

        if (commandAttr is null)
            return null;

        var commandName =
            commandAttr.ConstructorArguments.Length > 0
                ? commandAttr.ConstructorArguments[0].Value as string ?? classSymbol.Name
                : classSymbol.Name;

        var executeMethod = classSymbol
            .GetMembers()
            .OfType<IMethodSymbol>()
            .FirstOrDefault(m => m.Name == "ExecuteAsync");

        if (executeMethod is null)
            return null;

        var arguments = executeMethod
            .Parameters.Where(p =>
                p.GetAttributes()
                    .Any(a => a.AttributeClass?.ToDisplayString() == ArgumentAttributeName)
            )
            .Select(p => new ArgumentInfo(
                p.Name,
                p.Type.ToDisplayString(),
                p.NullableAnnotation == NullableAnnotation.Annotated,
                p.HasExplicitDefaultValue,
                p.HasExplicitDefaultValue
                    ? FormatDefaultValue(p.ExplicitDefaultValue, p.Type)
                    : null
            ))
            .ToImmutableArray();

        return new CommandInfo(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            commandName,
            arguments
        );
    }

    private static string FormatDefaultValue(object? value, ITypeSymbol type)
    {
        if (value is null)
            return "null";

        if (type.SpecialType == SpecialType.System_String)
            return $"\"{value}\"";

        if (type.SpecialType == SpecialType.System_Boolean)
            return value.ToString()!.ToLowerInvariant();

        return value.ToString()!;
    }

    private static void GenerateConsoleApp(
        SourceProductionContext ctx,
        ImmutableArray<CommandInfo?> commands
    )
    {
        var builder = new IndentingBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.CommandLine;");
        builder.AppendLine("using System.Diagnostics.CodeAnalysis;");
        builder.AppendLine("using System.Threading;");
        builder.AppendLine("using System.Threading.Tasks;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine("using Microsoft.Extensions.Hosting;");
        builder.AppendLine("");
        builder.AppendLine("namespace SystemCommandLineGenerator;");
        builder.AppendLine("");

        // Generate ConsoleApp static class
        builder.AppendLine("internal static class ConsoleApp");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("public static ConsoleAppBuilder CreateBuilder(string[] args) => new(args);");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        // Generate ConsoleAppBuilder
        builder.AppendLine("internal sealed class ConsoleAppBuilder");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine("private readonly string[] _args;");
        builder.AppendLine("private readonly List<Func<IServiceProvider, Command>> _commandFactories = [];");
        builder.AppendLine("private Func<IServiceProvider, RootCommand>? _rootCommandFactory;");
        builder.AppendLine("");

        builder.AppendLine("internal ConsoleAppBuilder(string[] args)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("_args = args;");
        builder.AppendLine("var settings = new HostApplicationBuilderSettings { Args = args };");
        builder.AppendLine("Host = Microsoft.Extensions.Hosting.Host.CreateEmptyApplicationBuilder(settings);");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        builder.AppendLine("public HostApplicationBuilder Host { get; }");
        builder.AppendLine("");

        // Generate a single AddCommand<T>() that switches on type
        builder.AppendLine("public ConsoleAppBuilder AddCommand<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>() where T : class");
        builder.AppendLine("{");
        builder.Indent();

        // Generate switch cases for each command
        var validCommands = commands.Where(c => c is not null).ToList();
        if (validCommands.Count > 0)
        {
            for (int i = 0; i < validCommands.Count; i++)
            {
                var cmd = validCommands[i]!;
                var prefix = i == 0 ? "if" : "else if";

                builder.AppendLine($"{prefix} (typeof(T) == typeof({cmd.FullTypeName}))");
                builder.AppendLine("{");
                builder.Indent();
                builder.AppendLine($"Host.Services.AddTransient<{cmd.FullTypeName}>();");

                if (cmd.IsRoot)
                {
                    builder.AppendLine($"_rootCommandFactory = Create{cmd.ClassName};");
                }
                else
                {
                    builder.AppendLine($"_commandFactories.Add(Create{cmd.ClassName});");
                }

                builder.Dedent();
                builder.AppendLine("}");
            }

            builder.AppendLine("else");
            builder.AppendLine("{");
            builder.Indent();
            builder.AppendLine("throw new InvalidOperationException($\"Type '{typeof(T).FullName}' is not a registered command.\");");
            builder.Dedent();
            builder.AppendLine("}");
        }
        else
        {
            builder.AppendLine("throw new InvalidOperationException($\"Type '{typeof(T).FullName}' is not a registered command.\");");
        }

        builder.AppendLine("");
        builder.AppendLine("return this;");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");

        // Generate private factory methods for each command
        foreach (var cmd in commands)
        {
            if (cmd is null)
                continue;

            GenerateCommandFactory(builder, cmd);
            builder.AppendLine("");
        }

        // Generate RunAsync
        builder.AppendLine("public async Task<int> RunAsync()");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("Host.Services.AddSingleton<RootCommand>(sp =>");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("RootCommand root = _rootCommandFactory is not null");
        builder.AppendLine("    ? _rootCommandFactory(sp)");
        builder.AppendLine("    : new RootCommand();");
        builder.AppendLine("");
        builder.AppendLine("foreach (var factory in _commandFactories)");
        builder.AppendLine("{");
        builder.Indent();
        builder.AppendLine("root.Subcommands.Add(factory(sp));");
        builder.Dedent();
        builder.AppendLine("}");
        builder.AppendLine("");
        builder.AppendLine("return root;");
        builder.Dedent();
        builder.AppendLine("});");
        builder.AppendLine("");
        builder.AppendLine("var host = Host.Build();");
        builder.AppendLine("var rootCommand = host.Services.GetRequiredService<RootCommand>();");
        builder.AppendLine("return await rootCommand.Parse(_args).InvokeAsync();");
        builder.Dedent();
        builder.AppendLine("}");

        builder.Dedent();
        builder.AppendLine("}");

        ctx.AddSource("ConsoleApp.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void GenerateCommandFactory(IndentingBuilder builder, CommandInfo info)
    {
        var returnType = info.IsRoot ? "RootCommand" : "Command";

        builder.AppendLine($"private static {returnType} Create{info.ClassName}(IServiceProvider sp)");
        builder.AppendLine("{");
        builder.Indent();

        builder.AppendLine($"var instance = sp.GetRequiredService<{info.FullTypeName}>();");
        builder.AppendLine("");

        // Create arguments
        foreach (var arg in info.Arguments)
        {
            if (arg.HasDefaultValue)
            {
                builder.AppendLine(
                    $"var {arg.Name}Argument = new Argument<{arg.TypeName}>(\"{arg.Name}\") {{ DefaultValueFactory = _ => {arg.DefaultValue} }};"
                );
            }
            else
            {
                builder.AppendLine(
                    $"var {arg.Name}Argument = new Argument<{arg.TypeName}>(\"{arg.Name}\");"
                );
            }
        }

        if (info.Arguments.Length > 0)
            builder.AppendLine("");

        // Create the command
        if (info.IsRoot)
        {
            builder.AppendLine("var command = new RootCommand();");
        }
        else
        {
            builder.AppendLine($"var command = new Command(\"{info.CommandName}\");");
        }

        foreach (var arg in info.Arguments)
        {
            builder.AppendLine($"command.Arguments.Add({arg.Name}Argument);");
        }

        builder.AppendLine("");
        builder.AppendLine("command.SetAction(async (parseResult, ct) =>");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var arg in info.Arguments)
        {
            if (arg.IsNullable)
            {
                // Nullable type - null is a valid value
                builder.AppendLine($"var {arg.Name}Value = parseResult.GetValue({arg.Name}Argument);");
            }
            else
            {
                // Non-nullable type - use defensive guard (S.CL enforces required args)
                builder.AppendLine($"var {arg.Name}Value = parseResult.GetValue({arg.Name}Argument)");
                builder.AppendLine($"    ?? throw new InvalidOperationException(\"Argument '{arg.Name}' was not provided.\");");
            }
        }

        var argValues = string.Join(", ", info.Arguments.Select(a => $"{a.Name}Value"));
        builder.AppendLine($"await instance.ExecuteAsync({argValues});");

        builder.Dedent();
        builder.AppendLine("});");
        builder.AppendLine("");
        builder.AppendLine("return command;");

        builder.Dedent();
        builder.AppendLine("}");
    }

    private sealed record CommandInfo(
        string Namespace,
        string ClassName,
        string CommandName,
        ImmutableArray<ArgumentInfo> Arguments
    )
    {
        public bool IsRoot => string.IsNullOrEmpty(CommandName);

        public string FullTypeName => string.IsNullOrEmpty(Namespace) || Namespace == "<global namespace>"
            ? $"global::{ClassName}"
            : $"global::{Namespace}.{ClassName}";
    }

    private sealed record ArgumentInfo(
        string Name,
        string TypeName,
        bool IsNullable,
        bool HasDefaultValue,
        string? DefaultValue
    );
}
