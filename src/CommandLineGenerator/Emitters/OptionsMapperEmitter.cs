// SPDX-FileCopyrightText: Copyright (c) 2026 Logan Bussell
// SPDX-License-Identifier: MIT

using StaticCs;

namespace CommandLineGenerator.Emitters;

/// <summary>
/// Emits the generated mapper class for an options type.
/// The mapper provides methods to add options/arguments to a command and parse them from a ParseResult.
/// </summary>
internal static class OptionsMapperEmitter
{
    /// <summary>
    /// Generates the source code for an options mapper class.
    /// </summary>
    public static string Emit(OptionsTypeInfo info)
    {
        var builder = new IndentingBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.CommandLine;");
        builder.AppendLine("using System.CommandLine.Parsing;");
        builder.AppendLine("");

        var hasNamespace = !string.IsNullOrEmpty(info.Namespace) && info.Namespace != Namespaces.Global;
        if (hasNamespace)
        {
            builder.AppendLine($"namespace {info.Namespace};");
            builder.AppendLine("");
        }

        var mapperName = $"{info.TypeName}Mapper";
        builder.AppendLine($"internal static class {mapperName}");
        builder.AppendLine("{");
        builder.Indent();

        // Generate private static symbol properties
        foreach (var member in info.Members)
        {
            var propName = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";

            if (member.IsArgument)
            {
                builder.AppendLine(
                    $"private static Argument<{member.TypeName}> {propName} {{ get; }} = CreateArgument_{member.PropertyName}();"
                );
            }
            else
            {
                builder.AppendLine(
                    $"private static Option<{member.TypeName}> {propName} {{ get; }} = CreateOption_{member.PropertyName}();"
                );
            }
        }

        builder.AppendLine("");

        // Generate AddTo method
        EmitAddToMethod(builder, info);

        builder.AppendLine("");

        // Generate Parse method
        EmitParseMethod(builder, info);

        // Generate private factory methods for each symbol
        foreach (var member in info.Members)
        {
            builder.AppendLine("");
            EmitSymbolFactoryMethod(builder, member);
        }

        builder.Dedent();
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static void EmitAddToMethod(IndentingBuilder builder, OptionsTypeInfo info)
    {
        builder.AppendLine("internal static void AddTo(Command command)");
        builder.AppendLine("{");
        builder.Indent();
        foreach (var member in info.Members)
        {
            var propName = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";
            builder.AppendLine($"command.Add({propName});");
        }
        builder.Dedent();
        builder.AppendLine("}");
    }

    private static void EmitParseMethod(IndentingBuilder builder, OptionsTypeInfo info)
    {
        builder.AppendLine($"public static {info.FullTypeName} Parse(ParseResult parseResult)");
        builder.AppendLine("{");
        builder.Indent();

        var ctorArgs = new List<string>();
        foreach (var member in info.Members)
        {
            var symbolVar = $"{member.PropertyName}{(member.IsArgument ? "Argument" : "Option")}";

            if (member.IsNullable)
            {
                ctorArgs.Add($"parseResult.GetValue({symbolVar})");
            }
            else if (member.IsBoolean)
            {
                ctorArgs.Add($"parseResult.GetValue({symbolVar})");
            }
            else if (member.IsValueType && member.HasDefaultValue)
            {
                // For value types with defaults, don't use ??, just GetValue
                // System.CommandLine will use DefaultValueFactory automatically
                ctorArgs.Add($"parseResult.GetValue({symbolVar})");
            }
            else if (member.HasDefaultValue)
            {
                // For reference types (like string), use ?? operator
                ctorArgs.Add($"parseResult.GetValue({symbolVar}) ?? {member.DefaultValue}");
            }
            else
            {
                ctorArgs.Add(
                    $"parseResult.GetValue({symbolVar}) ?? throw new InvalidOperationException(\"{(member.IsArgument ? "Argument" : "Option")} '{member.CliName}' was not provided.\")"
                );
            }
        }

        builder.AppendLine($"return new {info.FullTypeName}(");
        builder.Indent();
        for (int i = 0; i < ctorArgs.Count; i++)
        {
            var suffix = i < ctorArgs.Count - 1 ? "," : ");";
            builder.AppendLine($"{ctorArgs[i]}{suffix}");
        }
        builder.Dedent();

        builder.Dedent();
        builder.AppendLine("}");
    }

    private static void EmitSymbolFactoryMethod(IndentingBuilder builder, OptionsMemberInfo member)
    {
        var methodName = $"Create{(member.IsArgument ? "Argument" : "Option")}_{member.PropertyName}";

        if (member.IsArgument)
        {
            EmitArgumentFactory(builder, member, methodName);
        }
        else
        {
            EmitOptionFactory(builder, member, methodName);
        }
    }

    private static void EmitArgumentFactory(IndentingBuilder builder, OptionsMemberInfo member, string methodName)
    {
        builder.AppendLine($"private static Argument<{member.TypeName}> {methodName}()");
        builder.AppendLine("{");
        builder.Indent();

        if (member.HasDefaultValue)
        {
            builder.AppendLine(
                $"var arg = new Argument<{member.TypeName}>(\"{member.CliName}\") {{ DefaultValueFactory = _ => {member.DefaultValue} }};"
            );
        }
        else
        {
            builder.AppendLine($"var arg = new Argument<{member.TypeName}>(\"{member.CliName}\");");
        }

        if (member.Description is not null)
        {
            builder.AppendLine($"arg.Description = \"{Utilities.EscapeString(member.Description)}\";");
        }

        builder.AppendLine("return arg;");
        builder.Dedent();
        builder.AppendLine("}");
    }

    private static void EmitOptionFactory(IndentingBuilder builder, OptionsMemberInfo member, string methodName)
    {
        builder.AppendLine($"private static Option<{member.TypeName}> {methodName}()");
        builder.AppendLine("{");
        builder.Indent();

        var optName = $"--{member.CliName}";

        if (member.IsBoolean)
        {
            builder.AppendLine($"var opt = new Option<bool>(\"{optName}\") {{ Arity = ArgumentArity.Zero }};");
            if (member.HasDefaultValue)
            {
                builder.AppendLine($"opt.DefaultValueFactory = _ => {member.DefaultValue};");
            }
        }
        else if (member.HasDefaultValue)
        {
            builder.AppendLine(
                $"var opt = new Option<{member.TypeName}>(\"{optName}\") {{ DefaultValueFactory = _ => {member.DefaultValue} }};"
            );
        }
        else
        {
            builder.AppendLine($"var opt = new Option<{member.TypeName}>(\"{optName}\");");
            if (!member.IsNullable)
            {
                builder.AppendLine("opt.Required = true;");
            }
        }

        if (member.Alias is not null)
        {
            builder.AppendLine($"opt.Aliases.Add(\"{member.Alias}\");");
        }

        if (member.Description is not null)
        {
            builder.AppendLine($"opt.Description = \"{Utilities.EscapeString(member.Description)}\";");
        }

        builder.AppendLine("return opt;");
        builder.Dedent();
        builder.AppendLine("}");
    }
}
